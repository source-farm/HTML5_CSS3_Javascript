@charset "utf-8";

/* Подключение внешнего шрифта. Правило @font-face всегда должно идти после правила @charset, но до каких-либо стилей,
   которые используют этот шрифт. */
@font-face {
    font-family: Quicksand;
    src: url('Quicksand-Regular.woff') format('woff'),
         url('Quicksand-Regular.ttf') format('trutype');
}

/*

========================================================================================================================
 Общие сведения
========================================================================================================================

Язык HTML не определяет как должен быть отображён документ: HTML определяет структуру домента и его содержимое(контент).
Вид документа определяется одним или несколькими таблицами стилей(style sheets), написанных на языке Cascading Style
Sheets(CSS).

Вид страницы не определяется какой-то одной таблицей стилей: её вид собирается из нескольких стилей, которые имеют
строгий приоритет. Вот список этих стилей в порядке возрастания приоритета:

    - стили браузера         - browser styles(или его ещё называют user agent styles)
    - пользовательские стили - user-defined styles
    - внешние стили          - external styles
    - встроенные стили       - embedded styles
    - инлайн стили           - inline styles

1. Стили браузера.
   В отсутствии каких-либо других стилей к документу применяются стили браузера, т.е. стили, которые встроенны в браузер.

2. Пользовательские стили.
   Более высокий приоритет чем стили браузера имеют пользовательские стили. Это стили, которые пользователь определил
   настройкой браузера. Например, пользователь может увеличить шрифт страницы по-умолчанию.

3. Внешние стили.
   Ещё выше находятся внешние стили - это стили, которые создатель страницы определил и сохранил в CSS файлах, которые
   затем подключил к документу. Один стиль можно подключить к нескольким страницам, что упрощает придание единого облика
   всему сайту.

4. Встроенные стили.
   Над внешними стилями находятся встроенные стили - стили, которые определены в заголовке(head) документа. Такие стили
   применяются только к документу, в котором они определены и недоступны за его пределами.

5. Инлайн стили.
   Самый высокий приоритет имеют инлайн стили - стили, которые определены как атрибуты элемента, а следовательно применимы
   только к нему

Использование встроенных и инлайн стилей не считается хорошей практикой, т.к. они нарушают основной принцип HTML, следуя
которому весь дизайн документа должен быть определён вне этого документа, а HTML используется только для описания
структуры и содержимого документа.

========================================================================================================================
 Правила стиля
========================================================================================================================

Если теги элемента являются строительными блоками HTML документа, то правила стиля(style rules) являются строительными
блоками CSS таблицы стилей. Правила стиля имеют следующую общую форму:

    selector {
        property1: value1;
        property2: value2;
        ...
    }

Здесь selector идентифицирует один элемент или группу элементов внутри документа, а пары property: value определяют
свойства стиля и их значения, которые применяются к элементу(ам). Например, следующее правило стиля:

    h1 {
        color: red;
        text-align: center;
    }

устанавливает для всех заголовков h1 в документе красный цвет и выравнивание по центру. Можно указывать несколько
селекторов через запятые:

    h1, h2 {
        color: red;
    }

CSS также как и HTML игнорирует пробельные символы. Поэтому предыдущее правило можно было бы создать и так:

    h1, h2 {color: red;}

========================================================================================================================
 Расширения браузера
========================================================================================================================

Вдобавок к поддерживаемым W3C свойствам стилей большинство браузеров предоставляют расширенную библиотеку свойств, которые
называются расширениями браузера(browser extensions). Многие стили, которые включаются в спецификацию CSS, начинают свой путь
как расширения браузера. Расширения каждого браузера имеют специфичный для этого браузера префикс(vendor prefix):

    -moz-    - Firefox
    -ms-     - Internet Explorer
    -o-      - Opera
    -webkit- - Chrome, Safari

Например, используя CSS3 можно отображать контент в отдельных столбцах, количество которых указывается с помощью свойства
column-count. Для того чтобы указать это свойство в правиле так, чтобы оно поддерживалось и старыми браузерами и новыми,
сначала необходимо указывать расширения браузера, а затем свойство самого CSS3:

    article {
        -webkit-column-count: 3;
        -moz-column-count: 3;
        column-count: 3;
    }

В общем случае браузеры обрабатывают свойства стилей в порядке, в котором они перечислены, игнорируя свойства, которые
они не смогли распознать или не поддерживают.

========================================================================================================================
 Встраиваемые и инлайн стили
========================================================================================================================

Встраиваемые стили добавляются непосредственно в заголовок HTML документ с помощью элемента style:

    <style>
        style rules
    </style>

Например, следующий код присваивает красный цвет тексту в заголовках h1 и выравнивает текст по-центру:

    <style>
        h1 {
            color: red;
            text-align: center;
        }
    </style>

При прочих равных условиях, стили загруженные последними имеют приоритет над определёнными ранее стилями. В следующем коде
браузер загружает встраиваемый стиль после внешних стилей, давая встраиваемым стилям больший приоритет:

    <link href="tss_styles.css" rel="stylesheet" />
    <style>
        style rules
    </style>

Если мы поменяем местами встраиваемый и внешний стили, то внешний стиль будет иметь больший приоритет.

Инлайн стили применяются непосредственно к конкретному элементу с помощью атрибута style:

    <element style="property1: value1;property2: value2; ...">
        content
    </element>

Например, следующий код делает текст внутри заголовка h1 красным и выравнивает текст по центру:

    <h1 style="color: red; text-align: center;">
        Tri and Succed Sports
    </h1>

Этот стиль применяется только конкретно к этому заголовку h1: к другим заголовам h1 внутри этой страницы и в других
HTML документах этот стиль не применяется. В общем случае не рекомендуется использовать инлайн стили, т.к. это усложняет
изменения стиля всего сайта.

========================================================================================================================
 Специализация, приоритеты и наследование стилей
========================================================================================================================

Имея такое большое количество источников стилей, должен какой-то метод разрешения конфликтов при применении нескольких
стилей к одному элементу. Мы уже изучили, что последний загруженный стиль имеет больший приоритет, чем загруженные до
него стили, но есть и другое важное правило применения стилей:

    Более специализированный стиль имеет приоритет над более общим стилем.

Таким образом, применённый к параграфу стиль имеет больший приоритет, чем стиль, применённый ко всей странице и стиль,
применённый к части текста внутри параграфа имеет приоритет над стилем самого параграфа. Например, в следующем коде
стиль, который присваивает цвету текста внутри параграфа красный цвет, имеет больший приоритет над стилем чёрного цвета
текста, применённого к остальному документу, т.к. этот стиль является более специализированным:

    p {color: red;}
    body {color: black;}

Также следует иметь в виду, что правило специализации применяется, когда есть конфликтующие свойства из нескольких
правил стилей. Когда свойства разные, то применяются оба правила. Если два правила имеют одинаковую специализацию, то
применяется тот, который был определён последним.

Ещё одним фактором, влияющим на рендеринг элементов, является наследование стилей: это когда свойства передаются от
родительского элемента дочерним. Например, следующее правило устанавливает цвет текста внутри статьи красным и этот
цвет получают все текстовые элементы, определённые внутри статьи: параграфы, заголовки и т.д.:

    article {color: red;}
    p {text-align: center;}

В общем мы получаем, что вид любого элемента на странице определяется на основе правил из разных таблиц стилей и свойств,
переданных от одного элемента другим в иерархии элементов. Эти таблицы стилей и правила и формируют слово cascade в
языке CSS - Cascading Style Sheets.

========================================================================================================================
 Создание таблиц стилей
========================================================================================================================

Определить кодировку текста внутрии .css файла можно правилом @charset:

    @charset "encoding";

Здесь encoding указывает на кодировку файла. Это правило должно стоять в самом начале файла, даже до каких-либо
комментариев. Кодировку UTF-8 можно указать следующим правилом:

    @charset "utf-8";

Импортировать стили из файла можно правилом @import:

    @import url(<url>);

Здесь <url> - это URL внешнего файла стилей. Правила @charset и @import являются примерами так называемых
at-правил(at-rule) - это указания браузеру как нужно интерпретировать и парсить содержимое CSS файла. Правило @import
должно быть указано до каких-либо других правил стиля. Пример импорта стилей из файла:

    @import url(company.css);
    @import url(support.css);

========================================================================================================================
 Работа с цветом
========================================================================================================================

Цвет в CSS можно указать либо с помощью названия цвета либо значения. CSS поддерживает 147 названий цветов от самых
обычных как red, blue или black до экзотических как ivory, crimson, khaki.

Более точное цвета можно задать с помощью его числового представления. CSS поддерживает 2 типа представления цветов
с помощью чисел: RGB и HSL.

============================================================
 RGB
============================================================
RGB цвет задаётся тройкой интенсивности красного, зелёного и синего составляющих цвета:

    rgb(red, green, blue)

Интенсивность может меняться от 0 до 255 включительно. Например, белый цвет представляется как rgb(255, 255, 255). Всего
с помощью такой схемы можно представить около 16.7 миллионов цветов: больше, чем человеческий глаз может различить.
RGB цвет можно также представить и в 16-ричном виде:

    #redgreenblue

Например, жёлтый цвет, представленный в 10-ричном виде как rgb(255, 255, 0), в 16-ричном виде можно представить как
#FFFF00.
Также интенсивность компонентов RGB цвета можно определить с помощью процента: 100% - самая большая интенсивность,
0% - самая маленькая. Жёлтый цвет можно, например, представить как rgb(100%, 100%, 0%).

============================================================
 HSL
============================================================

HSL цвета появились в CSS3 и основаны на цветовой модели, в которой каждый цвет определяется тройкой тон, насыщенность и
яркость(hue, saturation, lightness):

    hsl(hue, saturation, lightness)

Тон может меняться от 0 до 360 градусов, где 0 обозначает красный цвет, 120 - зелёный и 240 - синий. Насыщенность и
яркость могут меняться от 0% до 100%. Жёлтый цвет в схеме HSL можно представить как hsl(60, 100%, 100%).

============================================================
 Прозрачность
============================================================

Прозрачность цвета можно установить с помощью свойств rgba или hsla:

    rgba(red, green, blue, opacity)
    hsla(hue, saturation, lightness, opacity)

Здесь opacity - это непрозрачность цвета, которая может меняться от 0.0(полностью прозрачный) до 1.0(полностью
непрозрачный).

========================================================================================================================
 Установка цвета фона и текста
========================================================================================================================

Для установки цвета текста и фона любого элемента CSS определяет следующие стили:

    color: <color>;
    background-color: <color>;

Здесь <color> - это либо числовое представление текста либо его название.

========================================================================================================================
 Адаптивный дизайн
========================================================================================================================

Адаптивный дизайн(progressive enhancement) - это когда сначала создаётся базовая версия сайта, которая работает даже на
самых старых браузерах, а затем накручивается функционал в зависимости от браузера пользователя и скорости работы его
Интернет-соединения. Игрушечным примером этой стратегии разработки сайта может служить следующий код:

    html {
        background-color: rgb(235, 177, 131);
        background-color: hsl(27, 72%, 72%);
    }

HSL цвета были введены в CSS3 и следовательно старые браузеры не поддерживают это свойство. Поэтому можно сначала
указать цвет в формате RGB, а затем в HSL. Старый браузер поймёт RGB цвет и пропустит непонятное ему свойство HSL.
Новый браузер применит последний цвет, т.е. HSL, т.к. он может распознать оба свойства.

========================================================================================================================
 CSS селекторы
========================================================================================================================

Следующее правило устанавливает цвет текста заголовка первого уровня в документе в красный цвет:

    h1 {
        color: red;
    }

Т.е. красными будут все заголовки h1, где бы они не встречались: в статье, в элементе aside, в футере и т.д. Но иногда
нам нужно применить стиль к h1, который расположен в определённом месте документа и ни к какому другому h1. Для этого
в CSS есть так называемые шаблоны селекторов(selector patterns), которые позволяют применить стиль только к тому
элементу, который удовлетворяет этому шаблону.

============================================================
 Контекстные селекторы
============================================================

Контекстные селекторы позволяют применить стиль к элементу, если он удовлетворяет контексту этого селектора. Под
контекстом подразумевается иерархическое взаимоотношение между элементами HTML документа, в котором есть родители,
дети, потомки и т.д. Контекстный селектор имеет следующий общий вид:

    parent descendant { styles }

Здесь parent - это родительский элемент; descendant - потомок родителя, т.е. элемент, который находится внутри элемента
parent в HTML документе и необъязательно он должен быть прямым потомком(т.е. ребёнком) parent'а; styles - стили,
которые нужно применить к элементу descendant. Например, следующий код устанавливает цвет текста внутри заголовка h1
в красный, но только в том случае, если заголовок находится внутри header'а:

    header h1 {
        color: red;
    }

Как мы уже говорили, h1 не должен быть прямым потомком header'а, чтобы это правило сработало, т.е. оно применится и к
следующему HTML коду:

    <header>
        <div>
            <h1>Tri and Succeed Sports</h1>
        </div>
    </header>

Контекстные селекторы подчиняются общему правилу, которое мы обсуждали выше: более специализированное правило имеет
приоритет над более общим. Например, следующие правила устанавливают цвет текста в заголовках h1 внутри элемента
section в красный цвет, а в остальных случаях в голубой:

    section h1 { color: red; }
    h1 { color: blue; }

CSS поддерживает следующие виды контекстных селекторов:

    *                 - любой элемент
    elem              - элемент elem в любом месте документа
    elem1, elem2, ... - любой из элементов elem1, elem2 и т.д. в любом месте документа
    parent descendant - элемент descendant, который находится где-либо в иерархии под элементов parent
    parent > child    - элемент child, который непосредственным потомком элемента parent
    elem1 + elem2     - элемент elem2, если непосредственно перед ним на одном уровне иерархии находится элемент elem1
    elem1 ~ elem2     - элемент elem2, если где-либо перед ним на одном уровне иерархии находится элемент elem1

Например, следующее правило присваивает голубой цвет текста дочерним элементам(т.е. потомкам 1-го уровня) элемента
article:

    article > * { color: blue; }

============================================================
 Селекторы на основе атрибутов элементов
============================================================

Селекторы можно также определять на основе наличия определённых атрибутов у элементов и их значений. Наиболее часто
используемыми такими атрибутами являются id и class. Для того чтобы применить стиль к элементу на основе значения
атрибута id нужно использовать один из следующих селекторов:

    #<id>

    или

    elem#<id>

Здесь <id> - это значение атрибута id. Т.к. предполагается, что значения атрибутов id являются уникальными в пределах
документа, подходят обе эти способа. Например, селектор следующего заголовка h1:

    <h1 id="title">Tri and Succeed Sports</h1>

может быть равен #title или h1#title. Оба способа являются эквивалентными.

Т.к. два элемента внутри HTML документа не могут иметь одинаковый id, для группирования сходных по какому-либо свойству
элементов используется атрибут class. Например, следующие элементы h1 и p принадлежат классу intro:

    <h1 class="intro">Tri and Succeed Sports</h1>
    <p class="intro">...</p>

Селектор элементов на основе класса может иметь один из следующих видов:

    .<class>

    или

    elem.<class>

Здесь <class> - это значение атрибута class, а elem - элемент. Селектор .<class> позволяет выбрать все элементы, у
которых атрибут class равен <class>, а селектор elem.<class> - конкретный элемент elem, у которого атрибут class равен
<class>. Например, для заголовка h1, приведённого выше, селектор будет таким:

    h1.intro { color: blue; }

Хотя id и class являются наиболее часто используемыми атрибутами в селекторах на основе атрибутов, такие селекторы могут
использовать любые атрибуты и их значения.

========================================================================================================================
 Работа с шрифтами
========================================================================================================================

============================================================
 Выбор шрифта
============================================================

По-умолчанию многие браузеры используют шрифт Times New Roman для отображения букв или символов. Установить свой шрифт
можно с помощью свойства font-family:

    font-family: <fonts>;

Здесь <fonts> - это список разделённых через запятые конкретных шрифтов(specific font) или обобщённых шрифтов(generic
font). По-другому этот список ещё называют стеком шрифтов(font stack). Конкретный шрифт - это шрифт, который имеет
точное название как Times New Roman или Helvetica и находится на машине пользователя или в сети. Обобщённый шрифт
описывает общий вид символов текста, не определяя какой именно шрифт нужно использовать. Браузер на основе описания
обобщённого шрифта выбирает подходящий конкретный шрифт. CSS поддерживает следующие обобщённые группы шрифтов:

    serif      - шрифт с засечками
    sans-serif - шрифт без засечек
    monospace  - шрифт, у которого каждый символ имеет одинаковую ширину
    cursive    - курсивный шрифт
    fantasy    - сильно закрученные шрифт, используемый для декорации. Никогда не должен использоваться внутри body.

Т.к. при указании обобщённого шрифта разработчик не контролирует какой шрифт будет выбран браузером, при формировании
шрифтов выбирают следующий подход: в начале указывают конкретные шрифты, а в конце обобщённые. Браузер выберет тот
шрифт, который будет найден первым. Например, стиль

    font-family: 'Arial Black', Gadget, sans-serif;

указывает браузеру, что первым должен быть выбран шрифт Arial Black, если он доступен. Если нет, то шрифт Gadget.
Если и этого шрифта нет, то выбрать какой-то шрифт на усмотрение браузера из семейства sans-serif. Если название
шрифта состоит из нескольких слов, то оно должно быть заключено в одинарные или двойные кавычки.

Т.к. набор доступных шрифтов сильно разнится в зависимости от операционной системы или устройства, выбор шрифта
ограничен семейством безопасных веб шрифтов(safe web fonts), которые скорее всего окажутся на машине пользователя.
К таким шрифтам относятся Arial, Arial Black, Verdana и др. Общепринятым является выбор шрифтов из семейства
sans-serif для заголовков и текста и использование serif шрифтов для специальных эффектов или большого раземера текста.

Безопасные веб шрифты довольно сильно ограничивают разработчика в выборе шрифта. Поэтому в CSS можно указать браузеру
использовать внешний файл шрифта. Шрифты могут быть различных форматов, самыми распространёнными являются TTF(TrueType)
и WOFF(Web Open Font Format). Внешний шрифт добавляется с помощью правила @font-face:

    @font-face {
        font-family: name;
        src: url('url1') format('text1'),
             url('url2') format('text2'),
             ...;
        descriptor1: value1;
        descriptor2: value2;
        ...
    }

Здесь name - это название шрифта, url - местонахождение файла шрифта, text - необъязательное текстовое описание формата
шрифта(хотя рекомендуется всё-таки указать его, чтобы браузер не загружал шрифт, который не понимает) и пары
descriptor: value - необъязательные свойства, которые описывают когда шрифт должен быть использован. Например:

    @font-face {
        font-family: Gentium;
        src: url('Gentium.woff') format('woff'),
             url('Gentium.ttf') format('truetype');
    }

указывает браузеру загрузить шрифт Gentium.woff. Если это не удалось сделать, можно попытаться загрузить тот же шрифт,
но уже формата TrueType. Следующее правило:

    @font-face {
        font-family: Gentium;
        src: url('GentiumBold.woff') format('woff'),
             url('GentiumBold.ttf') format('truetype');
        font-weight: bold;
    }

указывает браузеру загрузить специальный вариант жирных шрифтов Gentium, когда текст необходимо отобразить именно
в этом виде.
После определения шрифта с помощью правила @font-face, можно включить его в стек шрифтов:

    font-family: Gentium, 'Arial Black', Gadget, sans-serif. 

============================================================
 Определение размера шрифта
============================================================

Размер шрифта устанавливается с помощью свойства font-size:

    font-size: size;

Здесь size - это длина(length) шрифта в CSS единицах измерения. Размер, выраженный в этих единицах измерения, может
быть как целочисленным(0, 1, 2, ...) так и вещественным(0.1, 2.3, ...). Длина(и ширина) в CSS можно выразить в
абсолютных или относительных единицах.

Абсолютные единицы позволяют установить фиксированный размер текста вне зависимости от устройства и обычно
используется только с принтерами. Они определяются в одном из пяти стандартных единиц измерения:

    mm - миллиметры
    cm - сантиметры
    in - дюймы
    pt - пункты(points)
    pc - пики(1 пика = 35/83 см)

Например, установить размер текста в 12 пунктов внутри body можно так:

    body {
        font-size: 12pt;
    }

Между размером текста и его единицей измерения не должно быть пробела.

Абсолютные единицы используют не так часто по той причине, что разработчик не знает заранее характеристики устройства,
которое будет рендерить страницу. Поэтому вместо них часто используют относительные единицы, которые выражаются
относительно размера других объектов внутри страницы или относительно возможностей устройства по отображению данных.
Основной относительной единицей является пиксел(px), т.к. размер пикселя зависит от плотности пикселей устройства(ppi -
pixels per inch): на стационарных мониторах ppi может быть равен 96, а на мобильном устройстве 200 или даже 300. Обычно
браузеры устанавливают базовый размер текста внутри body в 16px, а заголовки h1, h2 и h3 чуть больше. Пример:

    body {
        font-size: 10px;
    }

    h1 {
        font-size: 14px;
    }

Точное отображение текста, размер которого выражен в пикселях, сильно зависит от устройства, т.к. как мы уже говорили
на разных устройствах разный ppi: 10px может нормально смотреться на мониторе, но на мобильнике текст может быть
попросту нечитаемым.

============================================================
 Масштабирование шрифта с помощью em'ов или rem'ов
============================================================

Т.к. разработчик не знает заранее свойств устройства, на котором будет отображаться страница, текст страницы делают
масштабируемым, выразив размер всех шрифтов относительно размера шрифта по-умолчанию. Есть три относительные единицы
измерения для применения масштабирования:

    - проценты
    - em'ы
    - rem'ы

Проценты и em'ы устанавливают размер шрифта относительно размера шрифта родительского элемента. Например, следующее
правило:

    h1 {
        font-size: 200%;
    }

делает размер текста заголовка h1 2 раза больше размера текста его родительского элемента. То же самое с помощью
em'ов можно сделать так:

    h1 {
        font-size: 2em;
    }

Относительные единицы проходят каскадом по элементам страницы. Например, в следующем коде:

    body { font-size: 16px; }
    body > aritcle { font-size: 0.75em; }
    body > aritcle > h1 { font-size: 1em; }

заголовк h1 в итоге будет иметь размер шрифта 12px - такой же как и у article, хотя на первый взгляд может показаться,
что его размер должен быть больше, чем размер article'а(1em > 0.75em): размер шрифта h1 определяется относительно
его родителя, т.е. article'а.

Чтобы избежать такой путаницы некоторые разработчики ратуют за использование rem'ов(root em). В этом случае размеры
шрифтов всегда указываются относительно размера шрифта элемента html. В следующем примере:

    html { font-size: 16px; }
    article { font-size: 0.75rem; }
    article > h1 { font-size: 1rem; }

элемент article получает размер 12px, а h1 - 16px.

============================================================
 Масштабирование шрифта относительно размера окна браузера
============================================================

CSS3 также позволяет установить длину шрифта относительно текущего размера окна браузера. Для этого используются
4 единицы измерения:

    1vw   - 1% ширины окна браузера
    1vh   - 1% высоты окна браузера
    1vmin - меньшее из 1vw и 1vh
    1vmax - большее из 1vw и 1vh

Преимуществом таких единиц является масштабирование размера шрифтов в соответствии с размеров окна браузера.
Недостатотком является нечитаемость текста, когда окно браузера становится слишком маленьким.

============================================================
 Ключевые слова для обозначения размера шрифта
============================================================

Размер шрифта можно также указать с помощью следующих ключевых слов:

    xx-small
    x-small
    small
    medium
    large
    x-large
    xx-large
    larger
    smaller

Размер шрифта, который соответствует каждому из этих ключевых слов, опеределяется браузером. larger и smaller являются
относительными размерами. Например, в следующем примере:

    aside { font-size: small; }
    aside > h1 { font-size: larger; }

заголовк h1, который является дочерним элементом элемента aside, должен иметь размер шрифта больший, чем у aside.

========================================================================================================================
 Управление интервалами между элементами текста и выравниванием
========================================================================================================================

CSS позволяет установить межбуквенный(kerning), межсловный(tracking) и межстрочный(leading) интервалы. Межбуквенный
и межсловный интервалы можно контроллировать с помощью следующих свойств:

    letter-spacing: value;
    word-spacing: value;

Здесь value можно указывать в тех же идиницах, что и для размера шрифтов. Значения по-умолчанию как для межбуквенного
так и для межсловного интервалов равно 0 пикселям. Положительное значение увеличивает расстояние, отрицательное
уменьшает.

Расстояние между строками устанавливается свойством line-height:

    line-height: size;

Здесь size - это значение или процент от размера шрифта текста, к которому применяется это свойство. Если не указана
единица измерения, то size представляет собой соотношение высоты строки к размеру шрифта. По-умолчанию оно равно 1.2,
т.е. строка имеет высоту на 20% больше, чем размер шрифта. Но можно сделать этот размер больше в 2 раза:

    line-height: 2;

CSS также позволяет сместить начало первой строки блока текста с помощью свойства text-indent:

    text-indent: size;

Здесь size можно выразить в абсолютных или относительных единицах или в процентах от ширины блока текста. size также
может быть и отрицательным, что приведёт к смещению текста влево, создавая эффект свисающего текста.

========================================================================================================================
 Управление стилем текста
========================================================================================================================

Для управления начертанием текста можно воспользоваться свойством font-style:

    font-style: type;

Здесь type может принимать значения normal, italic или oblique. italic и oblique похожи по своему стилю, но могут
немного отличаться в зависимости от используемого шрифта.

Жирность текста устанавливается свойством font-weight:

    font-weight: weight;

Здесь weight может принимать значения от 100 до 900 с шагом 100, но на практике очень сложно различить жирность с такой
точностью. Также weight может быть равен lighter или bolder, которые позволяют указать жирность относительно
родительского элемента.

Можно добавить также и декоративные элементы элементы к тексту с помощью свойства text-decoration:

    text-decoration: type;

Здесь type может быть равен none, underline, overline или line-through. Можно также указывать несколько декораций
через пробел.

Для управления регистром текста внутри элемента исользуют свойство text-transform:

    text-transform: type;

Здесь type может быть равен capitalize, uppercase, lowercase или none. capitalize позволяет сделать первую букву
каждого слова прописным.

И наконец свойство font-variant управляет так называемой вариацией текста:

    font-variant: type;

Здесь type может принимать значения normal(нет вариации) или small-caps(маленькие строчные буквы).

============================================================
 Выравнивание текста по горизонтали или вертикали
============================================================

Текст можно выравнить по горизонтали или вертикали относительно родительского элемента. По горизонтали можно выравнить
свойством text-align:

    text-align: alignment;

Здесь alignment может быть равно left, right, center или justify(выравнить текст как по левому так и правому краям).

Для вертикального выравнивания пользуются свойством vertical-align:

    vertical-align: alignment;

Здесь alignment может принимать значения baseline, bottom, middle, sub, super, text-bottom, text-top или top. Вместо
этих значений можно также указывать проценты: положительные перемещают текст вверх, отрицательные вниз. Процент
указывается относительно высоты строки текста(line length).

============================================================
 Объединение всех свойств в одном стиле
============================================================

Большинство свойств текста и шрифта можно объединить в одно правило следующего вида:

    font: style variant weight size/height family;

Здесь style - это стиль текста(normal, italic или oblique), variant - вариант, weight - жирность, size - размер(то, что
устанавливается через свойство font-size), height - высота строки(то, что устанавливается через свойство line-height) и
family - стек шрифтов. Пример:

    font: italic small-caps bold 1.5em/2em Arial, sans-serif;

Объязательными являются только свойства size и family. Остальные можно не указывать, но если указать, то они должны
идти в том порядке, в котором они перечислены в правиле выше.

========================================================================================================================
 Форматирование списков
========================================================================================================================

============================================================
 Стиль списка
============================================================

По-умолчанию браузеры отображают элементы списка вместе с символом, который называют маркером списка(list marker):
неупорядоченные списки отображаются с жирной точкой, упорядоченные - числами. Чтобы отобразить другой символ или вообще
его убрать можно воспользоваться свойством list-style-type:

    list-style-type: type;

Здесь type может принимать значения none, disc, circle, decimal, lower-roman и др. Например, следующее правило
обозначает каждый элемент упорядоченного списка большими римскими буквами:

    ol {
        list-style-type: upper-roman;
    }

============================================================
 Использование изображений в качестве маркеров
============================================================

Маркеры элементов списка можно определить и с помощью изображений, используя свойство list-style-image:

    list-style-image: url(<url>);

Здесь <url> - путь до изображения. Маркеры-изображения можно использовать только для неупорядоченных списков. Пример:

    ul {
        list-style-image: url(redball.png);
    }

============================================================
 Управление расположением маркера
============================================================

CSS считает все элементы списка блочными элементами, расположенными внутри виртуального прямоугольника, за пределами
которого находятся маркеры. Это поведение по-умолчанию можно изменить с помощью свойства list-style-position:

    list-style-position: position;

Здесь position может принимать значения outside(используется по-умолчанию) и inside.

Все свойства стиля списка, описанные выше, можно также определить и одним свойством list-style:

    list-style: type image position;

Здесь type - это тип маркера, image - изображение маркера и position - расположение маркера. Если указать изображение
маркера, то тип маркера применяется только если изображение не найдено.

========================================================================================================================
 Поля, рамка и отступы элемента
========================================================================================================================

Блочные элементы как параграфы, списки или заголовки подчиняются так называемой боксовой модели(box model) CSS, следуя
которой контент элемента заключается в несколько концентрических прямоугольников:

    - контент самого элемента
    - поля(padding)   - идут от контента элемента до рамки
    - рамка(border)   - простанство вокруг поля
    - отступы(margin) - пространство между рамкой и следующим элементом

На картинке это всё выглядит намного нагляднее:

-----------------------------------------------------------------------------------------------
|                                     Отступы(margin)                                         |
|                                                                                             | 
|      ---------------------------------------------------------------------------------      |
|      |                               Рамка(border)                                   |      | 
|      |                                                                               |      | 
|      |      -------------------------------------------------------------------      |      | 
|      |      |                        Поля(padding)                            |      |      | 
|      |      |                                                                 |      |      | 
|      |      |      -----------------------------------------------------      |      |      | 
|      |      |      |                                                   |      |      |      | 
|      |      |      |                                                   |      |      |      | 
|      |      |      |                    Контент                        |      |      |      | 
|      |      |      |                                                   |      |      |      | 
|      |      |      |                                                   |      |      |      | 
|      |      |      -----------------------------------------------------      |      |      | 
|      |      |                                                                 |      |      | 
|      |      |                        Поля(padding)                            |      |      | 
|      |      -------------------------------------------------------------------      |      | 
|      |                                                                               |      | 
|      |                               Рамка(border)                                   |      | 
|      ---------------------------------------------------------------------------------      |
|                                                                                             | 
|                                     Отступы(margin)                                         |
-----------------------------------------------------------------------------------------------

Встроенные в браузер таблицы стилей устанавливают размеры отступов, рамки и полей, но их можно менять, определив
свою таблицу стилей.

Размер поля можно установить с помощью свойства padding:

    padding: size;

Здесь size выражается в одной из единиц измерения длины CSS или size может быть равно auto, чтобы браузер сам выбрал
размер. Например, следующее правило устанавливает размер поля вокруг каждого параграфа равным 20px:

    p {
        padding: 20px;
    }

Размер поля можно также определить для каждой стороны виртуального бокса:

    padding: top right bottom left;

Здесь top, right, bottom и left - размеры полей вдоль верхнего, правого, нижнего и левого краёв. Можно указывать не все
значения:

    - если указать одно значения, то оно применяется во все стороны одинаково
    - если указать два значения, то первое значение определяет размер полей вдоль верхнего и нижнего краёв, а второе
      вдоль правого и левого.
    - если указать три значения, то первое значение определяет размер вдоль верхней границы, второе - вдоль правого и
      левого краёв и третье - вдоль нижнего края.

Если нужно определить размер только вдоль одной границы поля, то можно воспользоваться следующими свойствами:

    padding-top: size;
    padding-right: size;
    padding-bottom: size;
    padding-left: size;

Размеры отступов устанавливаются также как и размеры полей, только вместо слова padding ввезде используется margin:

    margin: size;
    margin: top right bottom left;
    margin-top: size;
    margin-right: size;
    margin-bottom: size;
    margin-left: size;

Для установки размеров рамки используется следующие свойства:

    border-width: size;
    border-width: top right bottom left;
    border-width-top: size;
    border-width-right: size;
    border-width-bottom: size;
    border-width-left: size;

========================================================================================================================
 Псевдо-классы и псевдо-элементы
========================================================================================================================

При создании таблицы стилей можно обращаться к некоторым элементам или значениям атрибута class из HTML документа, даже
если их реально там нет. Такие элементы и атрибуты class называются псевдо-элементами и псевдо-классами.

============================================================
 Псевдо-классы
============================================================

Псевдо-класс классифицирует элемент на основе его текущего статуса, положения или использования в документе. Его
селектор имеет следующий вид:

    element:pseudo-class

Здесь element - это некий элемент из HTML документа, а pseudo-class - название CSS псевдо-класса. Псевдо-классы делятся
на структурные и динамические. Структурные псевдо-классы классифицируют элемент на основе его расположения в HTML
документе. Некоторые структурные псевдо-классы, которые поддерживает CSS:

    :root          - корневой элемент документа(html)
    :empty         - элемент без контента
    :only-child    - единственный элемент на некотором уровне иерархии
    :first-child   - первый среди дочерних элементов родителя
    :last-child    - последний среди дочерних элементов родителя
    :first-of-type - первый потомок родителя определённого типа

Например, следующий селектор выбирает первый элемент неупорядоченного списка:

    ul > li:first-of-type

Этот селектор работает так как будто у первого элемента списка был определён атрибут class равный "first-of-type", но
только для обращения к нему используется :, а не . как это делается для обычных классов. 

*/

/* HTML and Body Styles */

html {
    /* Установка фона всего документа в оранжевый цвет. */
    background-color: hsl(27, 72%, 72%);
}

body {
    /* Установка цвета текста всех элементов, которые находятся внутри body, в тёмно-серый цвет. */
    color: rgb(91, 91, 91);

    /* Установка цвета фона части документа, которая оказалась внутри body, в цвет слоновой кости(ivory). Остальной фон будет
       оранжевым благодаря селектору html, который определён выше. */
    background-color: ivory;

    /* Шрифты */
    font-family: Verdana, Geneva, sans-serif;
}





/* Heading Styles */

h1 {
    /* 2.2em увеличивает размер текста h1 в 2.2 раза относительно размера текста его родительского элемента. */
    font-size: 2.2em;
}

h2 {
    font-size: 1.5em;
}

h1, h2 {
    font-family: Quicksand, Verdana, Geneva, sans-serif;

    /* Увеличение расстояния между буквами заголовков h1 и h2. По-умолчанию равно 0. Отрицательное значение уменьшает
       расстояние. */
    letter-spacing: 0.1em;
}

/* Установка цвета текста в белый на оранжевом фоне в заголовках h1, которые находятся внутри элемента article с атрибутом
   id равным about_tss. */
article#about_tss h1 {
    color: white;
    background-color: rgb(222, 128, 60);
}

/* Установка цвета текста в белый на светло-оранжевом фоне в заголовках h2, которые находятся внутри элемента article с атрибутом
   id равным about_tss. */
article#about_tss h2 {
    color: white;
    background-color: rgb(235, 177, 131);
}

/* Установка цвета текста в серый на светло-фиолетовом фоне в заголовках h1 и h2, которые находятся внутри элемента article с
   атрибутом class равным syllabus. */
article.syllabus h1, article.syllabus h2 {
    color: rgb(101, 101, 101);
    background-color: rgb(255, 185, 255);
}





/* Aside and Blockquote Styles */

aside {
    /* Установка размера текста внутри элемента aside в 80% от размера текста его родительского элемента. */
    font-size: 0.8em;
}

aside blockquote {
    /* Присваивание светло-оранжевого цвета тексту элемента blockquote, который находится где-либо внутри элемента aside. */
    color: rgb(232, 165, 116);

    /* Установка размера отступов вдоль верхней и нижней границы равной 20px, а вдоль правой и левой - 5px. */
    margin: 20px 5px;
}





/* Navigation Styles */	

nav {
    font-size: 0.8em;
}

nav > ul {
    /* Увеличение расстояния между строками. По-умолчанию равно 1.2em. */
    line-height: 2em;

    /* Не отображать маркер для элементов неупорядоченного списка внутри элемента nav. */
    list-style-type: none;

    /* По-умолчанию браузеры выделяют 40 пикселей для левого поля списка(padding) на отображение маркеров, но если
       убрать маркеры(что сделано в верхнем правиле), то это левое поле не уменьшается, а остаётся такого же размера
       40 пикселей. Поэтому мы здесь вручную сокращаем это поле до 5 пикселей. */
    padding-left: 5px;
}

/* Установка верхнего поля элемента неупорядоченного списка класса newgroup внутри элемента nav равным 20px. */
nav > ul > li.newgroup {
    margin-top: 20px;
}





/* List Styles */

/* Использование изображения как маркера элементов неупорядоченного списка. */
/*
article#about_tss ul {
    list-style-image: url(runicon.png);
}
*/

/* Выбор первого элемента типа li из неупорядоченного списка внутри элемента article с атрибутом id равным "about_tss".
   */
article#about_tss ul li:first-of-type {
    list-style-image: url(runicon.png);
}

/* Выбор второго элемента типа li из неупорядоченного списка внутри элемента article с атрибутом id равным "about_tss".
   */
article#about_tss ul li:nth-of-type(2) {
    list-style-image: url(bikeicon.png);
}

/* Выбор последнего элемента типа li из неупорядоченного списка внутри элемента article с атрибутом id равным
   "about_tss". */
article#about_tss ul li:last-of-type {
    list-style-image: url(swimicon.png);
}

/* Отображать римскими большими цифрами упорядоченный список, который находится внутри элемента article класса syllabus
   */
article.syllabus ol {
    list-style-type: upper-roman;
}

/* Отображать большими буквами упорядоченный вложенный список второго уровня, который находится внутри элемента article
   класса syllabus */
article.syllabus ol ol {
    list-style-type: upper-alpha;
}

/* Отображать десятичными числами упорядоченный вложенный список третьего уровня, который находится внутри элемента
   article класса syllabus */
article.syllabus ol ol ol {
    list-style-type: decimal;
}





/* Footer Styles */

/* Применение стиля к элементу address, который находится где-то внутри элемента footer, который является
   дочерним элементом элемента body. */
body > footer address {
    /* Цвет фона */
    background-color: rgb(222,128,60);

    /* Цвет текста(пример адаптивного дизайна). */
    color: white;
    color: rgba(255, 255, 255, 0.7);

    /* Стиль шрифта обычный(без курсива), маленькие заглавные буквы, жирный текст, размер текста 0.9em, межстрочный
       интервал 3em и в конце стек шрифтов. */
    font: normal small-caps bold 0.9em/3em Quicksand, Verdana, Geneva, sans-serif;

    /* Выравнивание текста внутри элемента address по центру. */
    text-align: center;
}
