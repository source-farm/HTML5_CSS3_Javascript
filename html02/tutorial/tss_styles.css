@charset "utf-8";

/* Подключение внешнего шрифта. Правило @font-face всегда должно идти после правила @charset, но до каких-либо стилей,
   которые используют этот шрифт. */
@font-face {
    font-family: Quicksand;
    src: url('Quicksand-Regular.woff') format('woff'),
         url('Quicksand-Regular.ttf') format('trutype');
}

/*

========================================================================================================================
 Общие сведения
========================================================================================================================

Язык HTML не определяет как должен быть отображён документ: HTML определяет структуру домента и его содержимое(контент).
Вид документа определяется одним или несколькими таблицами стилей(style sheets), написанных на языке Cascading Style
Sheets(CSS).

Вид страницы не определяется какой-то одной таблицей стилей: её вид собирается из нескольких стилей, которые имеют
строгий приоритет. Вот список этих стилей в порядке возрастания приоритета:

    - стили браузера         - browser styles(или его ещё называют user agent styles)
    - пользовательские стили - user-defined styles
    - внешние стили          - external styles
    - встроенные стили       - embedded styles
    - инлайн стили           - inline styles

1. Стили браузера.
   В отсутствии каких-либо других стилей к документу применяются стили браузера, т.е. стили, которые встроенны в браузер.

2. Пользовательские стили.
   Более высокий приоритет чем стили браузера имеют пользовательские стили. Это стили, которые пользователь определил
   настройкой браузера. Например, пользователь может увеличить шрифт страницы по-умолчанию.

3. Внешние стили.
   Ещё выше находятся внешние стили - это стили, которые создатель страницы определил и сохранил в CSS файлах, которые
   затем подключил к документу. Один стиль можно подключить к нескольким страницам, что упрощает придание единого облика
   всему сайту.

4. Встроенные стили.
   Над внешними стилями находятся встроенные стили - стили, которые определены в заголовке(head) документа. Такие стили
   применяются только к документу, в котором они определены и недоступны за его пределами.

5. Инлайн стили.
   Самый высокий приоритет имеют инлайн стили - стили, которые определены как атрибуты элемента, а следовательно применимы
   только к нему

Использование встроенных и инлайн стилей не считается хорошей практикой, т.к. они нарушают основной принцип HTML, следуя
которому весь дизайн документа должен быть определён вне этого документа, а HTML используется только для описания
структуры и содержимого документа.

========================================================================================================================
 Правила стиля
========================================================================================================================

Если теги элемента являются строительными блоками HTML документа, то правила стиля(style rules) являются строительными
блоками CSS таблицы стилей. Правила стиля имеют следующую общую форму:

    selector {
        property1: value1;
        property2: value2;
        ...
    }

Здесь selector идентифицирует один элемент или группу элементов внутри документа, а пары property: value определяют
свойства стиля и их значения, которые применяются к элементу(ам). Например, следующее правило стиля:

    h1 {
        color: red;
        text-align: center;
    }

устанавливает для всех заголовков h1 в документе красный цвет и выравнивание по центру. Можно указывать несколько
селекторов через запятые:

    h1, h2 {
        color: red;
    }

CSS также как и HTML игнорирует пробельные символы. Поэтому предыдущее правило можно было бы создать и так:

    h1, h2 {color: red;}

========================================================================================================================
 Расширения браузера
========================================================================================================================

Вдобавок к поддерживаемым W3C свойствам стилей большинство браузеров предоставляют расширенную библиотеку свойств, которые
называются расширениями браузера(browser extensions). Многие стили, которые включаются в спецификацию CSS, начинают свой путь
как расширения браузера. Расширения каждого браузера имеют специфичный для этого браузера префикс(vendor prefix):

    -moz-    - Firefox
    -ms-     - Internet Explorer
    -o-      - Opera
    -webkit- - Chrome, Safari

Например, используя CSS3 можно отображать контент в отдельных столбцах, количество которых указывается с помощью свойства
column-count. Для того чтобы указать это свойство в правиле так, чтобы оно поддерживалось и старыми браузерами и новыми,
сначала необходимо указывать расширения браузера, а затем свойство самого CSS3:

    article {
        -webkit-column-count: 3;
        -moz-column-count: 3;
        column-count: 3;
    }

В общем случае браузеры обрабатывают свойства стилей в порядке, в котором они перечислены, игнорируя свойства, которые
они не смогли распознать или не поддерживают.

========================================================================================================================
 Встраиваемые и инлайн стили
========================================================================================================================

Встраиваемые стили добавляются непосредственно в заголовок HTML документ с помощью элемента style:

    <style>
        style rules
    </style>

Например, следующий код присваивает красный цвет тексту в заголовках h1 и выравнивает текст по-центру:

    <style>
        h1 {
            color: red;
            text-align: center;
        }
    </style>

При прочих равных условиях, стили загруженные последними имеют приоритет над определёнными ранее стилями. В следующем коде
браузер загружает встраиваемый стиль после внешних стилей, давая встраиваемым стилям больший приоритет:

    <link href="tss_styles.css" rel="stylesheet" />
    <style>
        style rules
    </style>

Если мы поменяем местами встраиваемый и внешний стили, то внешний стиль будет иметь больший приоритет.

Инлайн стили применяются непосредственно к конкретному элементу с помощью атрибута style:

    <element style="property1: value1;property2: value2; ...">
        content
    </element>

Например, следующий код делает текст внутри заголовка h1 красным и выравнивает текст по центру:

    <h1 style="color: red; text-align: center;">
        Tri and Succed Sports
    </h1>

Этот стиль применяется только конкретно к этому заголовку h1: к другим заголовам h1 внутри этой страницы и в других
HTML документах этот стиль не применяется. В общем случае не рекомендуется использовать инлайн стили, т.к. это усложняет
изменения стиля всего сайта.

========================================================================================================================
 Специализация, приоритеты и наследование стилей
========================================================================================================================

Имея такое большое количество источников стилей, должен какой-то метод разрешения конфликтов при применении нескольких
стилей к одному элементу. Мы уже изучили, что последний загруженный стиль имеет больший приоритет, чем загруженные до
него стили, но есть и другое важное правило применения стилей:

    Более специализированный стиль имеет приоритет над более общим стилем.

Таким образом, применённый к параграфу стиль имеет больший приоритет, чем стиль, применённый ко всей странице и стиль,
применённый к части текста внутри параграфа имеет приоритет над стилем самого параграфа. Например, в следующем коде
стиль, который присваивает цвету текста внутри параграфа красный цвет, имеет больший приоритет над стилем чёрного цвета
текста, применённого к остальному документу, т.к. этот стиль является более специализированным:

    p {color: red;}
    body {color: black;}

Также следует иметь в виду, что правило специализации применяется, когда есть конфликтующие свойства из нескольких
правил стилей. Когда свойства разные, то применяются оба правила. Если два правила имеют одинаковую специализацию, то
применяется тот, который был определён последним.

Ещё одним фактором, влияющим на рендеринг элементов, является наследование стилей: это когда свойства передаются от
родительского элемента дочерним. Например, следующее правило устанавливает цвет текста внутри статьи красным и этот
цвет получают все текстовые элементы, определённые внутри статьи: параграфы, заголовки и т.д.:

    article {color: red;}
    p {text-align: center;}

В общем мы получаем, что вид любого элемента на странице определяется на основе правил из разных таблиц стилей и свойств,
переданных от одного элемента другим в иерархии элементов. Эти таблицы стилей и правила и формируют слово cascade в
языке CSS - Cascading Style Sheets.

========================================================================================================================
 Создание таблиц стилей
========================================================================================================================

Определить кодировку текста внутрии .css файла можно правилом @charset:

    @charset "encoding";

Здесь encoding указывает на кодировку файла. Это правило должно стоять в самом начале файла, даже до каких-либо
комментариев. Кодировку UTF-8 можно указать следующим правилом:

    @charset "utf-8";

Импортировать стили из файла можно правилом @import:

    @import url(<url>);

Здесь <url> - это URL внешнего файла стилей. Правила @charset и @import являются примерами так называемых
at-правил(at-rule) - это указания браузеру как нужно интерпретировать и парсить содержимое CSS файла. Правило @import
должно быть указано до каких-либо других правил стиля. Пример импорта стилей из файла:

    @import url(company.css);
    @import url(support.css);

========================================================================================================================
 Работа с цветом
========================================================================================================================

Цвет в CSS можно указать либо с помощью названия цвета либо значения. CSS поддерживает 147 названий цветов от самых
обычных как red, blue или black до экзотических как ivory, crimson, khaki.

Более точное цвета можно задать с помощью его числового представления. CSS поддерживает 2 типа представления цветов
с помощью чисел: RGB и HSL.

============================================================
 RGB
============================================================
RGB цвет задаётся тройкой интенсивности красного, зелёного и синего составляющих цвета:

    rgb(red, green, blue)

Интенсивность может меняться от 0 до 255 включительно. Например, белый цвет представляется как rgb(255, 255, 255). Всего
с помощью такой схемы можно представить около 16.7 миллионов цветов: больше, чем человеческий глаз может различить.
RGB цвет можно также представить и в 16-ричном виде:

    #redgreenblue

Например, жёлтый цвет, представленный в 10-ричном виде как rgb(255, 255, 0), в 16-ричном виде можно представить как
#FFFF00.
Также интенсивность компонентов RGB цвета можно определить с помощью процента: 100% - самая большая интенсивность,
0% - самая маленькая. Жёлтый цвет можно, например, представить как rgb(100%, 100%, 0%).

============================================================
 HSL
============================================================

HSL цвета появились в CSS3 и основаны на цветовой модели, в которой каждый цвет определяется тройкой тон, насыщенность и
яркость(hue, saturation, lightness):

    hsl(hue, saturation, lightness)

Тон может меняться от 0 до 360 градусов, где 0 обозначает красный цвет, 120 - зелёный и 240 - синий. Насыщенность и
яркость могут меняться от 0% до 100%. Жёлтый цвет в схеме HSL можно представить как hsl(60, 100%, 100%).

============================================================
 Прозрачность
============================================================

Прозрачность цвета можно установить с помощью свойств rgba или hsla:

    rgba(red, green, blue, opacity)
    hsla(hue, saturation, lightness, opacity)

Здесь opacity - это непрозрачность цвета, которая может меняться от 0.0(полностью прозрачный) до 1.0(полностью
непрозрачный).

========================================================================================================================
 Установка цвета фона и текста
========================================================================================================================

Для установки цвета текста и фона любого элемента CSS определяет следующие стили:

    color: <color>;
    background-color: <color>;

Здесь <color> - это либо числовое представление текста либо его название.

========================================================================================================================
 Адаптивный дизайн
========================================================================================================================

Адаптивный дизайн(progressive enhancement) - это когда сначала создаётся базовая версия сайта, которая работает даже на
самых старых браузерах, а затем накручивается функционал в зависимости от браузера пользователя и скорости работы его
Интернет-соединения. Игрушечным примером этой стратегии разработки сайта может служить следующий код:

    html {
        background-color: rgb(235, 177, 131);
        background-color: hsl(27, 72%, 72%);
    }

HSL цвета были введены в CSS3 и следовательно старые браузеры не поддерживают это свойство. Поэтому можно сначала
указать цвет в формате RGB, а затем в HSL. Старый браузер поймёт RGB цвет и пропустит непонятное ему свойство HSL.
Новый браузер применит последний цвет, т.е. HSL, т.к. он может распознать оба свойства.

========================================================================================================================
 CSS селекторы
========================================================================================================================

Следующее правило устанавливает цвет текста заголовка первого уровня в документе в красный цвет:

    h1 {
        color: red;
    }

Т.е. красными будут все заголовки h1, где бы они не встречались: в статье, в элементе aside, в футере и т.д. Но иногда
нам нужно применить стиль к h1, который расположен в определённом месте документа и ни к какому другому h1. Для этого
в CSS есть так называемые шаблоны селекторов(selector patterns), которые позволяют применить стиль только к тому
элементу, который удовлетворяет этому шаблону.

============================================================
 Контекстные селекторы
============================================================

Контекстные селекторы позволяют применить стиль к элементу, если он удовлетворяет контексту этого селектора. Под
контекстом подразумевается иерархическое взаимоотношение между элементами HTML документа, в котором есть родители,
дети, потомки и т.д. Контекстный селектор имеет следующий общий вид:

    parent descendant { styles }

Здесь parent - это родительский элемент; descendant - потомок родителя, т.е. элемент, который находится внутри элемента
parent в HTML документе и необъязательно он должен быть прямым потомком(т.е. ребёнком) parent'а; styles - стили,
которые нужно применить к элементу descendant. Например, следующий код устанавливает цвет текста внутри заголовка h1
в красный, но только в том случае, если заголовок находится внутри header'а:

    header h1 {
        color: red;
    }

Как мы уже говорили, h1 не должен быть прямым потомком header'а, чтобы это правило сработало, т.е. оно применится и к
следующему HTML коду:

    <header>
        <div>
            <h1>Tri and Succeed Sports</h1>
        </div>
    </header>

Контекстные селекторы подчиняются общему правилу, которое мы обсуждали выше: более специализированное правило имеет
приоритет над более общим. Например, следующие правила устанавливают цвет текста в заголовках h1 внутри элемента
section в красный цвет, а в остальных случаях в голубой:

    section h1 { color: red; }
    h1 { color: blue; }

CSS поддерживает следующие виды контекстных селекторов:

    *                 - любой элемент
    elem              - элемент elem в любом месте документа
    elem1, elem2, ... - любой из элементов elem1, elem2 и т.д. в любом месте документа
    parent descendant - элемент descendant, который находится где-либо в иерархии под элементов parent
    parent > child    - элемент child, который непосредственным потомком элемента parent
    elem1 + elem2     - элемент elem2, если непосредственно перед ним на одном уровне иерархии находится элемент elem1
    elem1 ~ elem2     - элемент elem2, если где-либо перед ним на одном уровне иерархии находится элемент elem1

Например, следующее правило присваивает голубой цвет текста дочерним элементам(т.е. потомкам 1-го уровня) элемента
article:

    article > * { color: blue; }

============================================================
 Селекторы на основе атрибутов элементов
============================================================

Селекторы можно также определять на основе наличия определённых атрибутов у элементов и их значений. Наиболее часто
используемыми такими атрибутами являются id и class. Для того чтобы применить стиль к элементу на основе значения
атрибута id нужно использовать один из следующих селекторов:

    #<id>

    или

    elem#<id>

Здесь <id> - это значение атрибута id. Т.к. предполагается, что значения атрибутов id являются уникальными в пределах
документа, подходят обе эти способа. Например, селектор следующего заголовка h1:

    <h1 id="title">Tri and Succeed Sports</h1>

может быть равен #title или h1#title. Оба способа являются эквивалентными.

Т.к. два элемента внутри HTML документа не могут иметь одинаковый id, для группирования сходных по какому-либо свойству
элементов используется атрибут class. Например, следующие элементы h1 и p принадлежат классу intro:

    <h1 class="intro">Tri and Succeed Sports</h1>
    <p class="intro">...</p>

Селектор элементов на основе класса может иметь один из следующих видов:

    .<class>

    или

    elem.<class>

Здесь <class> - это значение атрибута class, а elem - элемент. Селектор .<class> позволяет выбрать все элементы, у
которых атрибут class равен <class>, а селектор elem.<class> - конкретный элемент elem, у которого атрибут class равен
<class>. Например, для заголовка h1, приведённого выше, селектор будет таким:

    h1.intro { color: blue; }

Хотя id и class являются наиболее часто используемыми атрибутами в селекторах на основе атрибутов, такие селекторы могут
использовать любые атрибуты и их значения.

========================================================================================================================
 Работа с шрифтами
========================================================================================================================

============================================================
 Выбор шрифта
============================================================

По-умолчанию многие браузеры используют шрифт Times New Roman для отображения букв или символов. Установить свой шрифт
можно с помощью свойства font-family:

    font-family: <fonts>;

Здесь <fonts> - это список разделённых через запятые конкретных шрифтов(specific font) или обобщённых шрифтов(generic
font). По-другому этот список ещё называют стеком шрифтов(font stack). Конкретный шрифт - это шрифт, который имеет
точное название как Times New Roman или Helvetica и находится на машине пользователя или в сети. Обобщённый шрифт
описывает общий вид символов текста, не определяя какой именно шрифт нужно использовать. Браузер на основе описания
обобщённого шрифта выбирает подходящий конкретный шрифт. CSS поддерживает следующие обобщённые группы шрифтов:

    serif      - шрифт с засечками
    sans-serif - шрифт без засечек
    monospace  - шрифт, у которого каждый символ имеет одинаковую ширину
    cursive    - курсивный шрифт
    fantasy    - сильно закрученные шрифт, используемый для декорации. Никогда не должен использоваться внутри body.

Т.к. при указании обобщённого шрифта разработчик не контролирует какой шрифт будет выбран браузером, при формировании
шрифтов выбирают следующий подход: в начале указывают конкретные шрифты, а в конце обобщённые. Браузер выберет тот
шрифт, который будет найден первым. Например, стиль

    font-family: 'Arial Black', Gadget, sans-serif;

указывает браузеру, что первым должен быть выбран шрифт Arial Black, если он доступен. Если нет, то шрифт Gadget.
Если и этого шрифта нет, то выбрать какой-то шрифт на усмотрение браузера из семейства sans-serif. Если название
шрифта состоит из нескольких слов, то оно должно быть заключено в одинарные или двойные кавычки.

Т.к. набор доступных шрифтов сильно разнится в зависимости от операционной системы или устройства, выбор шрифта
ограничен семейством безопасных веб шрифтов(safe web fonts), которые скорее всего окажутся на машине пользователя.
К таким шрифтам относятся Arial, Arial Black, Verdana и др. Общепринятым является выбор шрифтов из семейства
sans-serif для заголовков и текста и использование serif шрифтов для специальных эффектов или большого раземера текста.

Безопасные веб шрифты довольно сильно ограничивают разработчика в выборе шрифта. Поэтому в CSS можно указать браузеру
использовать внешний файл шрифта. Шрифты могут быть различных форматов, самыми распространёнными являются TTF(TrueType)
и WOFF(Web Open Font Format). Внешний шрифт добавляется с помощью правила @font-face:

    @font-face {
        font-family: name;
        src: url('url1') format('text1'),
             url('url2') format('text2'),
             ...;
        descriptor1: value1;
        descriptor2: value2;
        ...
    }

Здесь name - это название шрифта, url - местонахождение файла шрифта, text - необъязательное текстовое описание формата
шрифта(хотя рекомендуется всё-таки указать его, чтобы браузер не загружал шрифт, который не понимает) и пары
descriptor: value - необъязательные свойства, которые описывают когда шрифт должен быть использован. Например:

    @font-face {
        font-family: Gentium;
        src: url('Gentium.woff') format('woff'),
             url('Gentium.ttf') format('truetype');
    }

указывает браузеру загрузить шрифт Gentium.woff. Если это не удалось сделать, можно попытаться загрузить тот же шрифт,
но уже формата TrueType. Следующее правило:

    @font-face {
        font-family: Gentium;
        src: url('GentiumBold.woff') format('woff'),
             url('GentiumBold.ttf') format('truetype');
        font-weight: bold;
    }

указывает браузеру загрузить специальный вариант жирных шрифтов Gentium, когда текст необходимо отобразить именно
в этом виде.
После определения шрифта с помощью правила @font-face, можно включить его в стек шрифтов:

    font-family: Gentium, 'Arial Black', Gadget, sans-serif. 

============================================================
 Определение размера шрифта
============================================================

Размер шрифта устанавливается с помощью свойства font-size:

    font-size: size;

Здесь size - это длина(length) шрифта в CSS единицах измерения. Размер, выраженный в этих единицах измерения, может
быть как целочисленным(0, 1, 2, ...) так и вещественным(0.1, 2.3, ...). Длина(и ширина) в CSS можно выразить в
абсолютных или относительных единицах.

Абсолютные единицы позволяют установить фиксированный размер текста вне зависимости от устройства и обычно
используется только с принтерами. Они определяются в одном из пяти стандартных единиц измерения:

    mm - миллиметры
    cm - сантиметры
    in - дюймы
    pt - пункты(points)
    pc - пики(1 пика = 35/83 см)

Например, установить размер текста в 12 пунктов внутри body можно так:

    body {
        font-size: 12pt;
    }

Между размером текста и его единицей измерения не должно быть пробела.

Абсолютные единицы используют не так часто по той причине, что разработчик не знает заранее характеристики устройства,
которое будет рендерить страницу. Поэтому вместо них часто используют относительные единицы, которые выражаются
относительно размера других объектов внутри страницы или относительно возможностей устройства по отображению данных.
Основной относительной единицей является пиксел(px), т.к. размер пикселя зависит от плотности пикселей устройства(ppi -
pixels per inch): на стационарных мониторах ppi может быть равен 96, а на мобильном устройстве 200 или даже 300. Обычно
браузеры устанавливают базовый размер текста внутри body в 16px, а заголовки h1, h2 и h3 чуть больше. Пример:

    body {
        font-size: 10px;
    }

    h1 {
        font-size: 14px;
    }

Точное отображение текста, размер которого выражен в пикселях, сильно зависит от устройства, т.к. как мы уже говорили
на разных устройствах разный ppi: 10px может нормально смотреться на мониторе, но на мобильнике текст может быть
попросту нечитаемым.

============================================================
 Масштабирование шрифта с помощью em'ов или rem'ов
============================================================

Т.к. разработчик не знает заранее свойств устройства, на котором будет отображаться страница, текст страницы делают
масштабируемым, выразив размер всех шрифтов относительно размера шрифта по-умолчанию. Есть три относительные единицы
измерения для применения масштабирования:

    - проценты
    - em'ы
    - rem'ы

Проценты и em'ы устанавливают размер шрифта относительно размера шрифта родительского элемента. Например, следующее
правило:

    h1 {
        font-size: 200%;
    }

делает размер текста заголовка h1 2 раза больше размера текста его родительского элемента. То же самое с помощью
em'ов можно сделать так:

    h1 {
        font-size: 2em;
    }

Относительные единицы проходят каскадом по элементам страницы. Например, в следующем коде:

    body { font-size: 16px; }
    body > aritcle { font-size: 0.75em; }
    body > aritcle > h1 { font-size: 1em; }

заголовк h1 в итоге будет иметь размер шрифта 12px - такой же как и у article, хотя на первый взгляд может показаться,
что его размер должен быть больше, чем размер article'а(1em > 0.75em): размер шрифта h1 определяется относительно
его родителя, т.е. article'а.

Чтобы избежать такой путаницы некоторые разработчики ратуют за использование rem'ов(root em). В этом случае размеры
шрифтов всегда указываются относительно размера шрифта элемента html. В следующем примере:

    html { font-size: 16px; }
    article { font-size: 0.75rem; }
    article > h1 { font-size: 1rem; }

элемент article получает размер 12px, а h1 - 16px.

*/

/* HTML and Body Styles */

html {
    /* Установка фона всего документа в оранжевый цвет. */
    background-color: hsl(27, 72%, 72%);
}

body {
    /* Установка цвета текста всех элементов, которые находятся внутри body, в тёмно-серый цвет. */
    color: rgb(91, 91, 91);

    /* Установка цвета фона части документа, которая оказалась внутри body, в цвет слоновой кости(ivory). Остальной фон будет
       оранжевым благодаря селектору html, который определён выше. */
    background-color: ivory;

    /* Шрифты */
    font-family: Verdana, Geneva, sans-serif;
}

/* Heading Styles */

h1, h2 {
    font-family: Quicksand, Verdana, Geneva, sans-serif;
}

/* Установка цвета текста в белый на оранжевом фоне в заголовках h1, которые находятся внутри элемента article с атрибутом
   id равным about_tss. */
article#about_tss h1 {
    color: white;
    background-color: rgb(222, 128, 60);
}

/* Установка цвета текста в белый на светло-оранжевом фоне в заголовках h2, которые находятся внутри элемента article с атрибутом
   id равным about_tss. */
article#about_tss h2 {
    color: white;
    background-color: rgb(235, 177, 131);
}

/* Установка цвета текста в серый на светло-фиолетовом фоне в заголовках h1 и h2, которые находятся внутри элемента article с
   атрибутом class равным syllabus. */
article.syllabus h1, article.syllabus h2 {
    color: rgb(101, 101, 101);
    background-color: rgb(255, 185, 255);
}

/* Aside and Blockquote Styles */

/* Присваивание светло-оранжевого цвета тексту элемента blockquote, который находится где-либо внутри элемента aside. */
aside blockquote {
    color: rgb(232, 165, 116);
}





/* Navigation Styles */	





/* List Styles */





/* Footer Styles */
