@charset "utf-8";

/*
========================================================================================================================
 Свойство display
========================================================================================================================

В предыдущих параграфах мы изучили, что в HTML элементы могут делиться на блочные(параграфы, заголовки и т.д.) и инлайн
элементы как a, cite, sub и т.д. Однако отображение элемента как блочного или инлайн элемента зависит от таблицы
стилей, а именно свойства display:

    display: type;

Здесь type может принимать следующие значения: block, table, inline, inline-block, run-in, inherit, list-item, none и
др. Например, чтобы поменять стиль отображения по-умолчанию для элемента img с инлайна на блочный, можно использовать
следующее правило:

    img {
        display: block;
    }

Также элемент можно скрыть, указав display равным none. При этом элемент остаётся частью документа, но документ
рендерится как будто этого элемента не было вообще(в CSS есть также свойство visibility, которое если равно hidden
скрывает контент элемента, но сам элемент занимает место на странице).

========================================================================================================================
 Сбрасывающая таблица стилей
========================================================================================================================

Иногда разработчики хотят начать работу над стилем документа с чистого листа, т.е. без стилей, который браузер применяет
в отсутствии явно определённых разработчиком. Для этого обычно создают так называемый сбрасывающую таблицу стилей(reset 
style sheet), в которой указываются начальные значения свойств элементов, которые интересуют разработчика. Примером
такого файла является файл таблицы стилей pc_reset.css этого урока.

========================================================================================================================
 Дизайн раскладки(layout) элементов
========================================================================================================================

При проектировании расположения элементов в основном приходится учитывать ширину экрана пользователя, т.к. страницу он
может и пролистать вниз/вверх, а пролистывание вправо/влево считается плохим дизайном. Ширина экрана может меняться
очень сильно, т.к. одну и ту же страницу можно открыть и на мобильном телефоне и на стационарном компьютере с большим
разрешением экрана.

============================================================
 Фиксированная, жидкая и резиновая раскладка
============================================================

Существует три способа расположения элементов на странице: фиксированный, жидкий и резиновый(fixed, fluid and elastic
layouts).

Фиксированный способ устанавливает неизменные значения размера страницы и элементов внутри неё, обычно в пикселях.
Например, ширину страницы можно установить равно 1280 пикселям и она не меняется какое бы разрешение не было на
устройстве пользователя. В этом случае страница может и не поместиться полностью на экране.

При жидком расположении ширина элементов страницы устанавливается как процент от доступной ширины экрана. Например,
ширина элемента body может быть установлена на заполнение 90% ширины экрана, а фотография с логотипом компании на 80%.
При этом страница автоматически меняет размеры в зависимости от разрешения экрана пользователя.

Резиновая раскладка похожа на жидкую, но в ней все размеры выражаются в em'ах и основаны на размере шрифта страницы
по-умолчанию. Если пользователь увеличивает размер шрифта, то и пропорционально увеличиваются все элементы страницы, в
том числе и фотографии. Недостатком такого подхода является то, что если пользователь установил слишком большой размер
шрифта по-умолчанию, то элементы могут не поместиться на экране.

Также веб постепенно движется в сторону отзывчивого дизайна(responsive design), при котором раскладка и дизайн страницы
меняются в зависимости от того на каком устройстве показывается страница. Страница имеет один набор стилей для
мобильных устройств, другой для планшетов и третий для ноутбуков и стационарных машин.

========================================================================================================================
 Ширина и высота элемента
========================================================================================================================

Ширина и высота элемента устанавливаются с помощью следующих свойств:

    width: value;
    height: value;

Здесь value является значением, выраженным в одной из единиц измерения длины CSS или процентом от ширины или высоты
родителя. Например, следующее правило устанавливает ширину тела страницы равной 95% своего родителя, т.е. окна браузера:

    body {
        width: 95%;
    }

Высоту обычно не устанавливают явно, т.к. браузеры автоматически подбирают её так, чтобы контент уместился в элемент.
Все блочные элементы, как например body, имеют ширину по-умолчанию равную 100%.

Также можно указать минимальные и максимальные размеры ширины и высоты с помощью следующих свойств:

    min-width: value;
    min-height: value;
    max-width: value;
    max-height: value;

Здесь value снова является значением, выраженным в одной из единиц измерения длины CSS(обычно в пикселях).  Например,
следующее правило устанавливает ширину тела страницы равной 95% окна браузера, но не меньше 640 и не больше 1680
пикселей:

    body {
        width: 95%;
        min-width: 640px;
        max-width: 1680px;
    }

Минимальные ширина и высота помогают улучшить читаемость текста: слишком длинные строки сложно читать, т.к. глазам
приходится сканировать длинную строку, а слишком короткие строки мешают восприятию текста из-за постоянных переносов
строк.

На то как свойства width и height определяют ширину и высоту блочного элемента влияет CSS cвойство box-sizing, которое
может быть равно трём значением:

    content-box
    border-box
    inherit

По-умолчанию это свойство равно content-box, который определяет, что свойство width устанавливает только ширину контента
блочного элемента без учёта ширины внутреннего отступа(padding), рамки(border). Т.е. общая ширина блочного элемента
будет складываться из значения, установленного через свойство width плюс ширина внутреннего отступа и рамки.

Если же свойство box-sizing установить равным border-box, то свойство width будет задавать ширину контента, внутреннего
отступа и рамки. В этом случае для вычисления ширины контента нужно будет отнять от width ширину внутреннего отступа и
рамки.

inherit означает унаследовать значение свойства от родителя.

Для следующего стиля:

    width:   200px;
    padding: 10px;
    border:  5px;

графически это можно изобразить так:

                                      Свойство box-sizing равно content-box
------------------------------------------------------------------------------------------------------------------
|                                                                                                                |
|                                                                                                                |
|     ------------------------------------------------------------------------------------------------------     |
|     |                                                                                                    |     |
|     |                                                                                                    |     |
|     |                                                                                                    |     |
|     |        ------------------------------------------------------------------------------------        |     |
|     |        |                                                                                  |        |     |
|     |        |                                                                                  |        |     |
| 5px |  10px  |                                       200px                                      |  10px  | 5px |
|     |        |<-------------------------------------------------------------------------------->|        |     |
|     |        |                                                                                  |        |     |
|     |        |                                                                                  |        |     |
|     |        ------------------------------------------------------------------------------------        |     |
|     |                                                                                                    |     |
|     |                                                                                                    |     |
|     |                                                                                                    |     |
|     ------------------------------------------------------------------------------------------------------     |
|                                                                                                                |
|                                                                                                                |
------------------------------------------------------------------------------------------------------------------

                                       Свойство box-sizing равно border-box
               ------------------------------------------------------------------------------------
               |                                                                                  |
               |                                                                                  |
               |     ------------------------------------------------------------------------     |
               |     |                                                                      |     |
               |     |                                                                      |     |
               |     |                                                                      |     |
               |     |        ------------------------------------------------------        |     |
               |     |        |                                                    |        |     |
               |     |        |                                                    |        |     |
               | 5px |  10px  |                        170px                       |  10px  | 5px |
               |     |        |<-------------------------------------------------->|        |     |
               |     |        |                                                    |        |     |
               |     |        |                                                    |        |     |
               |     |        ------------------------------------------------------        |     |
               |     |                                                                      |     |
               |     |                                                                      |     |
               |     |                                                                      |     |
               |     ------------------------------------------------------------------------     |
               |                                                                                  |
               |                                                                                  |
               ------------------------------------------------------------------------------------

То же самое касается и высоты.

Есть также один важный момент, который нужно учитывать при работе с плавающими элементами. Если контейнер(родительский
элемент) содержит только плавающие элементы, то его размеры автоматически не подстраиваются под размеры плавающих
элементов. На самом деле такой контейнер схлопывается(collapse): с точки зрения браузера этот контейнер является пустым
с высотой равной 0. Поэтому если даже изменить цвет его фона, то ничего не будет видно. Увидеть такой контейнер можно
только если визуализировать рамку(border: 2px solid red, например). Для того чтобы контейнер не схлопывался применяют
разные ухищрения. Например, можно использовать псевдо-элемент after для добавления пустого элемента после контейнера:

    <container>::after {
        clear: both;
        content: "";
        display: table;
    }

Здесь <container> - это селектор элемента(например, div), который содержит в себе плавающие элементы.

Фактически таким же решением является метод, который в сети можно найти как clearfix. Допустим у нас есть элемент div,
внутри которого и находятся плавающие элементы. Объявив этот div с классом clearfix, можно в таблицу стилей добавить
следующий код, чтобы div не схлопывался:

    .clearfix::after {
        clear: both;
        content: "";
        display: table;
    }

========================================================================================================================
 Центрирование блочных элементов
========================================================================================================================

============================================================
 Центрирование по горизонтали
============================================================

Блочные элементы можно центрировать горизонтально относительно родителя, установив отступы слева и справа равными auto.
Например, тело страницы можно центрировать относительно окна браузера так:

    body {
        margin-left: auto;
        margin-right: auto;
    }

============================================================
 Центрирование по вертикали
============================================================

Центрирование по вертикали является не такой простой задачей как может показаться на первый взгляд. С годами
выработались некие дизайнерские уловки для решения этой задачи. Одной из них является рендеринг родителя как ячейки
таблицы с заранее известной высотой. Например, отцентрировать по вертикали заголовк h1 внутри следующего div элемента:

    <div>
        <h1>Pandaisia Chocolates</h1>
    </div>

можно следующим правилом:

    div {
        height: 40px;
        display: table-cell;
        vertical-align: middle;
    }

В сети можно также найти ещё варианты.

========================================================================================================================
 Плавающий контент
========================================================================================================================

По-умолчанию блочные элементы занимают 100% ширины родителя, но если прижать блок влево(float to left) или право(float
to right), то его ширина меняется в соответствии с контентом. Например, прижатый к левому краю div освобождает место
справа от себя, что позволяет встать на это место другим элементам; при этом неплавающий контент обтекает div. Если не
прижимать блочные элементы никуда, то они будут рендерится друг за другом каждый с новой строки.

Чтобы элемент стал плавающим можно использовать свойство float:

    float: position;

Здесь position может быть равно none(по-умолчанию), left - элемент примыкает к левой границе или right - элемент
примыкает к правой границе. Если и другие сверстники(элементы с общим родителем) плавают вдоль одной границы, то они
располагаются в один ряд, если их общая ширина не превышает ширину родителя. Если превышает, то происходит перенос
элементов на следующую строку.

С плавающим контентом связано также свойство clear, которое может быть равно следующим значениям:

    left
    right
    both
    none

Это свойство позволяет очистить левый или/и правый края элемента от плавающих элементов. Например, если очистить
элемент слева, т.е. установить свойство clear этого элемента равным left, то слева от этого элемента не может быть
плавающих элементов, что приведёт к переносу такого элемента на новую строку. Для этого и используют это свойство.
Соответственно right очищает от плавающих элементов справа, both - по обеим краям, none - не очищает ни по одной
стороне и это значение является значением по-умолчанию.
*/

/* Body Styles */

body {
    /* Центрируем тело по горизонтали относительно окна браузера. */
    margin-left: auto;
    margin-right: auto;

    /* Устанавливаем ширину тела равной 95% его родителя, т.е. окна браузера, но не меньше 640 и не больше 960
       пикселей. */
    max-width: 960px;
    min-width: 640px;
    width: 95%;
}

/* Обозначем изображение в заголовке тела как блочный элемент с шириной равной ширине родителя. */
body > header > img {
    display: block;
    width: 100%;
}




/* Body Header Styles */

/* Устанавливаем ширину элементов списка равной 20% ширины родителя, т.е. самого списка. Тут выбрано именно 20%, т.к.
   список навигации класса horizontalNavigation внутри заголовка тела содержит ровно 5 элементов. */
body > header > nav.horizontalNavigation li {
    width: 20%;
}




/* Horizontal Navigation Styles */

/* Элементы списка навигации класса horizontalNavigation сделать плавающими слева, что приведёт к выстраиванию их
   в один ряд благодаря ширине в 20% от родителя, установленной в разделе Body Header Styles выше. */
nav.horizontalNavigation li {
    float: left;
    display: block;
}

/* Т.к. гипертекстовые элементы a являются инлайн элементами по-умолчанию, то цвет фона, опеределённый в файле
   pc_styles1.css, занимает только фон, находящийся непосредственно за текстом ссылки, что выглядит некрасиво. Поэтому
   делаем ссылки блочными элементами. */
nav.horizontalNavigation a {
    /* Можно убрать это свойство и открыть страницу pc_home.html, чтобы увидеть влияние этого свойства на список
       навигации. */
    display: block;
    text-align: center;
}




/* Left Column Styles */

section#leftColumn {
    /* Очистка от плавающих элеметов слева. */
    clear: left;

    float: left;
    padding: 1.5em;
    width: 33%;
}




/* Right Column Styles */

section#rightColumn {
    float: left;
    width: 67%;
}

section#rightColumn img {
    display: block;
    width: 100%;
}

section#rightColumn > nav.horizontalNavigation li {
    width: 25%;
}




/* Footer Styles */

footer {
    background-color: rgb(71, 52, 29);
    clear: left;
}

/* Добавляем псевдо-элемент после footer'а, чтобы избежать его схлопывания, т.к. он содержит только плавающие элементы.
   */
footer::after {
    clear: both;
    content: "";
    display: table;
}

footer > nav.verticalNavigation {
    float: left;
    width: 22%;
}

footer > section#contactInfo {
    float: left;
    width: 34%;
}

