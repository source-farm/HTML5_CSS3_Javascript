<!DOCTYPE html>

<!--
========================================================================================================================
 Введение в флексбоксы
========================================================================================================================

Основным недостатком грид раскладки на основе строк и столбцов является то, что для различных размеров экранов нужно
создавать различные раскладки, чтобы страницу можно было удобно просматривать. Для решения этой проблемы используют так
называемые флексбоксы(flexbox) - определяют одну раскладку, которая автоматически подстраивается под размеры экрана.

============================================================
 Введение в флексбоксы
============================================================

Флексбокс - это прямоугольник, который содержит элементы, размеры которых могут сокращаться или увеличиваться в
соответствии с границами прямоугольника. Т.е. в отличие от грид раскладки, в которой каждый элемент имеет определённый
размер, элементы внутри флексбокса адаптируются к размеру их контейнера. Это свойство превращает флексбоксы в очень
полезный инструмент для создания раскладок под различные размеры страницы.

Элементы внутри флексбокса располагаются вдоль так называемой главной оси(main axis), которая может быть как
горизонтальной так и вертикальной. Перпендикулярно главной оси идёт поперечная ось(cross axis), которая используется для
определения ширины или высоты каждого элемента.

Для того чтобы превратить элемент в флексбокс можно использовать одно из следующих свойств:

    display: flex;

    или

    display: inline-flex;

Здесь значение flex приводит к тому, что флексбокс будет начинаться с новой строки(подобно блочным элементам), а
значение inline-flex сохраняет флексбокс в той же строке, что и окружающий его контент.

============================================================
 Определение направления флексбокса
============================================================

По-умолчанию элементы внутри флексбокса расположены горизонтально слева направо, но ориентацию флексбокса можно
настроить с помощью свойства:

    flex-direction: direction;

Здесь direction может принимать значения row(по-умолчанию), column, row-reverse или column-reverse. row располагает
элементы слева направо, column - сверху вниз, row-reverse - справа налево, column-reverse - снизу вверх.

По-умолчанию элементы внутри флексбокса будут пытаться уместиться на одной строке либо горизонтально либо вертикально.
Но если это нельзя сделать, некоторые элементы могут переместиться на новую строку в соответствии с значением свойства:

    flex-wrap: type;

Здесь type может принимать значения nowrap(по-умолчанию), wrap - перемещать элементы на новую строку или wrap-reverse -
переместить элементы на новую строку, но с противоположной стороны текущей строки. Например, следующие свойства создают
флексбокс, элементы которого располагаются в столбец в направлении сверху вниз, но непоместившиеся элементы
располагаются на новом столбце в направлении снизу вверх и т.д.:

    display: flex;
    flex-direction: column;
    flex-wrap: column-reverse;

Свойства flex-direction и flex-wrap можно объединить в одно свойство flex-flow:

    flex-flow: direction type;

========================================================================================================================
 Работа с флекс-элементами
========================================================================================================================

Флекс-элементы(flex items) похожи на плавающие объекты с тем исключением, что они могут плавать как горизонтально так
и вертикально. Также можно менять порядок, в котором они отображаются. Хотя размеры флекс-элементов могут быть
зафиксированны с помощью CSS свойств width и height, они необъязательно должны быть такими. Флекс-элементы также могут
растягиваться, автоматически изменяя размеры, чтобы заполнить флексбокс. Флекс-раскладка фундаментально отличается от
грид-раскладки и необходимо думать о размерах и раскладке другим образом.

Когда элемент определяется как растягивающийся(flex), его размеры вычисляются на основе трёх CSS свойств:

    - flex-basis(базовый размер)
    - flex-grow(коэффициент растягивания)
    - flex-shrink(коэффициент сжатия)

Рассмотрим эти свойства по порядку.

============================================================
 Базовый размер флекс-элемента
============================================================

Базовый размер определяет первоначальный размер флекс-элемента до момента, когда браузер пытается адаптировать его под
флексбокс. Устанавливается он с помощью свойства:

    flex-basis: size;

Здесь size является одной из единиц измерения длины в CSS, процентом от размера флексбокса или ключевым словом auto
(используется по-умолчанию), который устанавливает размер на основе контента элемента или значений его свойств width и
height. Например, следующее правило устанавливает начальный размер элемента равным 200-м пикселям:

    aside {
        flex-basis: 200px;
    }

Т.к. флексбоксы могут быть горизонтальными или вертикальными, свойство flex-basis устанавливает либо начальную ширину
либо начальную высоту флекс-элемента в зависимости от ориентации флексбокса.

Значение свойства flex-basis нельзя приравнивать к свойствам width и height, которые используются при грид-раскладке,
т.к. это всего лишь начальный размер флекс-элемента. Окончательные размеры флекс-элемента определяются на основе
размеров флексбокса и других флекс-элементов внутри этого же флексбокса.

============================================================
 Коэффициент растягивания флекс-элемента
============================================================

После установки базового размера браузер будет пытаться втиснуть элемент в флексбокс. Скорость, с которой
флекс-элемент увеличивается в размере относительно скорости роста других флекс-элементов, определяется свойством:

    flex-grow: value;

Здесь value - это неотрицательное число, которое и определяет скорость роста. По-умолчанию flex-grow равно 0, что
означает, что элемент не увеличивается за пределы базового размера. Различные флекс-элементы внутри флексбокса могут
иметь различные скорости роста, которыя в значительной степени и определяют долю флексбокса, которую займёт каждый
элемент. Например, в следующем примере:

    div#item1 {
        flex-basis: 100px;
        flex-grow: 1;
    }

    div#item2 {
        flex-basis: 100px;
        flex-grow: 3;
    }

устанавливается базовый размер в 100 пикселей для каждого из элементов div, но коэффициент растягивания второго
элемента в 3 раза больше первого. Это означает, что при увеличении размера флексбокса, в который входят эти элементы,
на 200 пикселей, первый элемент получит от этих пикселей 50, а второй 150.

В отличие от грид-раскладки относительные размеры флекс-элементов необъязательно должны оставаться постоянными.
Например, в предыдущем примере первоначально элементы занимали одно и то же пространство в 100 пикселей, но когда
содержащий их флексбокс увеличился в размере, 1-й элемент стал занимать 37.5%(150/400) от его размера, а второй - 62.5%
(250/400). Чтобы относительные размеры были постоянными можно установить базовый размер всех флекс-элементов внутри
флексбокса равным 0px.

Одним из самых больших преимуществ флексбоксовой раскладки является то, что не нужно знать количество флекс-элементов,
которые входят в флексбокс, чтобы их относительные пропорции были одинаковыми. Например, следующие правила:

    nav ul {
        display: flex;
    }

    nav ul li {
        flex-basis: 0px;
        flex-grow: 1;
    }

устанавливают для элементов списка одинаковый размер и одинаковую скорость роста. Если в списке будет 4 элемента, то
каждый элемент будет занимать 25% общего размера списка, если 5 - то 20%. Не нужно как в случае с грид-раскладками
подстраивать размер элемента в процентах под новое количество элементов.

============================================================
 Коэффициент сжатия флекс-элемента
============================================================

Если общий размер флекс-элементов оказывается больше размера флексбокса, то возможны два варианта развития событий.
Если свойство flex-wrap флексбокса установлено в wrap, то один или более элементов переместятся на новую строку и будут
занимать доступное пространство на этих строках. Если же flex-wrap не равен wrap, то при уменьшении размера флексбокса
флекс-элементы внутри него будут продолжать сжиматься, занимая как и прежде свою строку или столбец. Скорость, с
которой элементы сжимаются относительно других элементов, определяется свойством:

    flex-shrink: value;

Здесь value - это неотрицательное значение, которое и определяет скорость сжатия. По-умолчанию flex-shrink равно 1.
Например, следующие правила:

    /* Флексбокс */
    div {
        display: flex;
        flex-wrap: nowrap;
    }

    /* Элемент с id #item1 внутри элемента div. */
    div #item1 {
        flex-basis: 200px;
        flex-grow: 1;
        flex-shrink: 3;
    }

    /* Элемент с id #item2 внутри элемента div. */
    div #item2 {
        flex-basis: 200px;
        flex-grow: 1;
        flex-shrink: 1;
    }

определяют, что элементы item1 и item2 будут занимать равную долю флексбокса, пока размер флексбокса больше либо равно
400 пикселям. Но когда размеры флексбокса окажутся меньше 400 пикселей, элемент item1 начнёт сокращаться в 3 раза
быстрее элемента item2.

Если flex-shrink равен 0, то флекс-элемент не будет сжиматься меньше своего базовго размера.

============================================================
 Свойство flex
============================================================

Все 3 описанных выше свойства можно определить с помощью одного свойства:

    flex: grow shrink basis;

Значением по-умолчанию для flex является:

    flex: 0 1 auto;

Следуя значению по-умолчанию, флекс-элемент будет автоматически увеличен, чтобы уместить свой контент или значение его
свойство width или height. Флекс-элемент не будет увеличиваться за этот размер, но может уменьшаться вместе с
флексбоксом.

Свойство flex может также принимать следующие значения:

    auto    - автоматически изменять размеры(эквивалентно flex: 1 1 auto;)
    initial - значение по-умолчанию(эквивалентно flex: 0 1 auto;)
    none    - не растягивающийся флексбокс(эквивалентно flex: 0 0 auto;)
    inherit - унаследовать флекс значения от родителя

========================================================================================================================
 Упорядочивание элементов внутри флексбокса
========================================================================================================================

Одной из основных правил, которой нужно следовать при дизайне страницы является разделение контента от его дизайна.
Однако самый базовая характеристика дизайна как порядок элементов довольно сложно поменять без изменения HTML кода
документа. Но с появлением флексбоксов ситуация улучшилась. Хотя порядок самих флексбоксов нельзя контролировать через
таблицу стилей, порядок элементов внутри флексбокса можно с помощью свойства:

    order: value;

Здесь value - это целочисленное значение. Элементы с меньшим значением value располагаются раньше, чем элементы с
большим значением. Если элементы имеют одинаковое значение order'а, то они показываются так, как расположены в HTML
документе. По-умолчанию order равно 0. Пример:

    div#item1 { order: 100; }
    div#item2 { order: -1; }
    div#item3 { order: 50; }

В этом примере первым будет показан элемент item2, за ним item3 и в конце item1 вне зависимости от того как они
расположены в HTML документе.

========================================================================================================================
 Управление флексбокс раскладкой
========================================================================================================================

Для контроля расположения элементов внутри флексбокса можно использовать CSS свойства:

    - justify-content
    - align-items
    - align-content

Рассмотрим их по порядку.

============================================================
 Выравнивание элементов вдоль главной оси
============================================================

По-умолчанию элементы располагаются вдоль начала главной оси флексбокса. Но их расположением можно управлять свойством:

    justify-content: placement;

Здесь placement может быть равно:

    - flex-start    - элементы располагаются в начале главной оси(используется по-умолчанию)
    - flex-end      - элементы располагаются в конце главной оси
    - center        - элементы центрируются вдоль главной оси
    - space-between - элементы располагаются равномерно вдоль главной оси, но первый и последний элементы находятся в
                      начале и конце оси
    - space-around  - элементы располагаются равномерно вдоль главной оси

Свойство justify-content имеет смысл использовать только тогда, когда размеры элементов являются фиксированными. Иначе
элементы просто будут заполнять флексбокс.

============================================================
 Выравнивание строк флексбокса
============================================================

Свойство align-content похоже на justify-content за тем исключением, что оно выравнивает целые строки элементов вдоль
поперечной оси флексбокса. Синтаксис имеет следующий вид:

    align-content: value;

Здесь value может принимать одно из следующих значений:

    - flex-start    - строки располагаются в начале поперечной оси
    - flex-end      - строки располагаются в конце поперечной оси
    - stretch       - строки растягиваются, что занять всю поперечную ось(используется по-умолчанию)
    - center        - строки центрируются вдоль поперечной оси
    - space-between - строки распределяются равномерно вдоль поперечной оси и при этом первая и последняя строка
                      находятся в начале и конце оси
    - space-around  - строки распределяются равномерно вдоль поперечной оси

Свойство align-content имеет смысл использовать когда строк больше одной, как при использовании переноса
флекс-элементов(wrap).

============================================================
 Выравнивание элементов вдоль поперечной оси
============================================================

Свойство align-items выравнивает каждый флекс-элемент вдоль поперечной оси и имеет следующий синтаксис:

    align-items: value;

Здесь value может принимать следующие значения:

    - flex-start - элементы располагаются в начале поперечной оси
    - flex-end   - элементы располагаются в конце поперечной оси
    - center     - элементы центрируются вдоль поперечной оси
    - stretch    - элементы растягиваются, что занять всю поперечную ось(используется по-умолчанию)
    - baseline   - элементы располагаются так, чтобы иметь одинаковое выравнивание вдоль базовой линии их контента

Свойство align-items имеет смысл использовать тогда, когда существует только одна строка из элементов.
Чтобы какой-то определённый элемент имел своё собственное выравнивание можно воспользоваться свойством:

    align-self: value;

Здесь value принимает те же самые значения, что и свойство align-items. Например, следующее правило располагает футер в
конце поперечной оси флексбокса вне зависимости от расположения других элементов:

    footer {
        align-self: flex-end;
    }

Свойства align-content и align-items имеют по-умолчанию значения stretch, что приводит к заполнению флекс-элементами
всего пространства вдоль поперечной оси. В итоге получается, что все элементы вдоль строки будут иметь одинаковую
высоту. Такого эффекта сложно добиться с грид-раскладкой, если явно не указывать высоту каждого элемента.

============================================================
 Центрирование элементов
============================================================

Одной из сложных проблем при дизайне раскладки является вертикальное центрирование элементов внутри контейнера. Хотя
для решения этой проблемы придумали множество хаков, до появления флексбоксов её нельзя было решить простыми образом.
Например, следующее правило центрирует дочерние элементы div'а как по горизонтали так и по вертикали:

    div {
        display: flex;
        justify-content: center;
        align-content: center;
    }

Один элемент или группу элементов на одной строке можно центрировать так:

    div {
        display: flex;
        justify-content: center;
        align-items: center;
    }

-->

<html>
<head>
   <title>Pre-K Classes at Trusted Friends</title>
   <meta charset="utf-8" />
   <meta name="viewport" content="width=device-width, initial-scale=1" />  
   <link href="tf_reset.css" rel="stylesheet" />
   <link href="tf_styles2.css" rel="stylesheet" />
   <link href="tf_flex.css" rel="stylesheet" />
   <link href="tf_navicon.css" rel="stylesheet" />
</head>

<body>
   <header>
      <img src="tf_logo.png" alt="Trusted Friends" />
      
      <nav class="horizontal">
         <a id="navicon" href="#"><img src="tf_navicon.png" alt="" /></a>
         <ul>
            <li><a href="tf_home.html">Home</a></li>
            <li><a href="#">Infants</a></li>
            <li><a href="#">Toddlers</a></li>
            <li><a href="#" id="currentPage">Pre-K</a></li>
            <li><a href="#">After School</a></li>
         </ul>
      </nav>
   </header>
   
   <aside>
      <h1>Schedule</h1>
      <ol>
         <li> 8:00 am: Arrival and Breakfast</li>
         <li> 9:00 am: Morning Group Time</li>
         <li> 9:25 am: Learning Centers</li>
         <li>11:00 am: Group Time</li>
         <li>11:15 am: Outdoor Play</li>
         <li>11:50 am: Lunch</li>
         <li>12:30 pm: Group Time</li>
         <li>12:45 pm: Rest Time</li>
         <li> 2:15 pm: Learning Centers</li>
         <li> 3:00 pm: Group Time</li>
         <li> 3:15 pm: Snack</li>
         <li> 4:15 pm: Learning Centers</li>
         <li> 5:00 pm: Departure and Cleanup</li>
      </ol>
   </aside>
   
   <section id="main">
      <article id="overview">
         <h1>Pre-K Classes</h1>
         <p>As preschoolers gain more self-esteem, they feel ready to take on the world. 
            Our preschool curriculum enhances their confidence by providing activities to 
            help them become problem solvers and nurture a love of learning. With independent 
            exploration, structured activities, and hands-on learning, our children develop 
            a variety of skills and knowledge in areas from mathematics to reading.</p>
         <p>We're proud of the work we do. Early learning standards, backed by education experts,
            inform the scope and sequence of our pre-k program. Our curriculum aligns to  
            72 learning standards progressing sequentially across six developmental domains. 
            Add to this a healthy dose of running, jumping and movement to keep children active 
            and you'll see why <em>Trusted Friends</em> is a true leader in early 
            childhood education.</p>
      </article>
      
      <section id="topics">
         <article>
            <h1>Language Skills</h1>
            <p>Language, literacy, and communication skills are embedded into a child's 
               daily experiences. We strive to create meaningful classroom experiences that 
               help children use and build a growing vocabulary.</p>
         </article>
         <article>
            <h1>Math Exploration</h1>
            <p>Pre-k children are enthusiastic mathematicians. Our instructors work to ensure that 
               our students don't simply learn numbers by rote, but instead build mathematical 
               understanding related to real, everyday problems. Our curriculum includes 
               important skills such as comparing and contrasting items by characteristics, 
               following complex directions in sequence, and solving simple number problems.</p>
         </article>
         <article>
            <h1>Science Studies</h1>
            <p>As their cognitive and physical abilities develop, children are able to develop and test 
               their own theories, and to engage in scientific reasoning. Our curriculum encourages students 
               to broaden their understanding of scientific disciplines, from physics to chemistry to 
               earth science. Children learn by participating in cooking projects and participating in 
               multi-skill experiments, handling mechanical tools.</p>
         </article>
         <article>
            <h1>Creative Expressions</h1>
            <p>Pre-kindergarten is an ideal time to introduce children to artistic expression. Our 
               pre-k teachers extend their student's skills and knowledge through process-oriented art 
               projects. We teach sculpting with clay and etching tools, writing and illustrating books, 
               and our students experience acting out original stories with costumes, props, and masks.</p>
         </article>
         <article>
            <h1>Cultural Sharing</h1>
            <p>Children are innately interested in the diversity of people and cultures. We 
               foster the development of all areas of a child's emotional intelligence including interpersonal 
               skills, compassion, and acceptance of personal responsibility. We believe in fostering 
               respect for different cultures, traditions, and life styles.</p>
         </article>
         <article>
            <h1>Physical Wellness</h1>
            <p>Pre-k children learn about becoming responsible for their own choices and decisions. 
               Our curriculum encourages students to learn physical wellness through physical activity, 
               healthy eating, and personal hygiene. Everyday our children learn about themselves and 
               others through supportive sharing times.</p>
         </article>
      </section>
      
   </section>
   
   <footer>
      Trusted Friends &#8226; 3450 Regency Lane, Carmel IN
   </footer>
</body>
</html>
